import{_ as t,c as i,o as a,ag as e}from"./chunks/framework.Bw-5EFTY.js";const d="/assets/complexity.Ce3QGNNb.jpg",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm-structure/basic.md","filePath":"algorithm-structure/basic.md","lastUpdated":null}'),o={name:"algorithm-structure/basic.md"};function r(n,l,h,c,s,u){return a(),i("div",null,l[0]||(l[0]=[e('<h2 id="前端常见的数据结构有哪些-有什么基础算法-有什么应用场景" tabindex="-1">前端常见的数据结构有哪些？有什么基础算法？有什么应用场景？ <a class="header-anchor" href="#前端常见的数据结构有哪些-有什么基础算法-有什么应用场景" aria-label="Permalink to &quot;前端常见的数据结构有哪些？有什么基础算法？有什么应用场景？&quot;">​</a></h2><h3 id="数组-字符串" tabindex="-1">数组/字符串 <a class="header-anchor" href="#数组-字符串" aria-label="Permalink to &quot;数组/字符串&quot;">​</a></h3><p>数组是数据的元素集合，字符串是字符的有序序列。</p><ul><li>基础算法： <ol><li>排序：冒泡排序、快速排序等</li><li>查找：二分查找</li></ol></li></ul><h3 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h3><p>链表（Linked List）是一种物理存储单元上<code>非连续、非顺序</code>的存储结构，是一种<code>线性数据结构</code>,数据元素的逻辑顺序是通过链表中的<code>指针链接次序</code>实现的。</p><ul><li>基础算法：遍历、反转</li><li>应用场景：链表常用于实现栈、队列等数据结构，以及在需要频繁插入删除的场景中替代数组。</li></ul><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p>栈（Stack）是一种运算受限的<code>线性数据结构</code>，遵循<code>后进先出（LIFO）原则</code>，仅允许在栈顶进行插入（入栈）和删除（出栈）操作。</p><ul><li>基础算法：<code>栈顶即表尾</code>进行入栈 push、出栈 pop</li><li>应用场景： <ol><li>函数调用（调用栈）：保存函数返回地址、参数和局部变量；实现递归调用</li><li>表达式求值：中缀表达式转后缀表达式、计算后缀表达式（逆波兰表示法）</li><li>括号匹配：检查代码中的括号是否成对出现</li><li>浏览器历史记录：前进后退功能实现</li><li>深度优先搜索（DFS）：图的遍历算法</li><li>撤销/重做 undo/redo：文本编辑器中的撤销功能</li><li>内存堆栈模型：栈内存区域用于存储局部变量</li></ol></li></ul><h3 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h3><p>队列是一种<code>先进先出（FIFO, First-In-First-Out）的线性数据结构</code>，类似于现实生活中的排队场景。</p><ul><li>基础算法：<code>队尾即表尾</code>入队 enqueue、<code>队首表头</code>出队 dequeue</li><li>应用场景： <ol><li>操作系统中的进程调度</li><li>打印机任务队列</li><li>消息队列系统</li><li>广度优先搜索（BFS）算法</li><li>数据流处理（如网络数据包传输）</li><li>客服系统中的呼叫排队</li><li>Event Loop 时间循环</li></ol></li></ul><h3 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h3><p>树是一种<code>非线性的层次化数据结构</code>，由节点（Node）和边（Edge）组成</p><ul><li>基础算法： 深度优先搜索 DFS、广度优先搜索 BFS</li><li>应用场景： <ol><li>文件系统目录结构</li><li>数据库索引（B树/B+树）</li><li>编译器语法分析（抽象语法树）</li><li>路由算法（最短路径树）</li><li>决策树（机器学习）</li><li>DOM树（网页文档对象模型）</li><li>游戏AI（行为树）</li></ol></li></ul><h4 id="二叉树🌲" tabindex="-1">二叉树🌲 <a class="header-anchor" href="#二叉树🌲" aria-label="Permalink to &quot;二叉树🌲&quot;">​</a></h4><ul><li>基础算法：前序遍历、中序遍历、后续遍历</li><li>应用场景： <ol><li>基础的二叉树应用场景不多，主要用于学习和面试 😄</li><li>二叉树扩展出来的，平衡二叉树、AVL 树、红黑树、B+ 树、Trie 树，有大量的应用场景，如数据库管理、文件系统管理、虚拟内存管理等</li><li>前端使用的场景较少，了解其基础知识即可</li></ol></li></ul><h4 id="堆🌲" tabindex="-1">堆🌲 <a class="header-anchor" href="#堆🌲" aria-label="Permalink to &quot;堆🌲&quot;">​</a></h4><p>堆是一种<code>‌完全二叉树</code>（所有层都填满，除了最后一层，最后一层从左到右填充）‌结构的顺序存储数组</p><ul><li><p>最大堆（Max-Heap）：每个父节点的值 ≥ 子节点的值（根节点最大）</p></li><li><p>最小堆（Min-Heap）：每个父节点的值 ≤ 子节点的值（根节点最小）</p></li><li><p>基础算法：堆排序</p></li><li><p>应用场景：</p><ol><li>内存堆栈模型</li><li>堆是一种高效维护极值的数据结构，广泛应用于算法优化和系统调度中。</li></ol></li></ul><h3 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-label="Permalink to &quot;图&quot;">​</a></h3><p>图是一种<code>非线性数据</code>结构，由节点（Vertex）和边（Edge）组成，用于表示实体之间的关系。</p><ul><li>基础算法： <ol><li>深度优先搜索 DFS</li><li>广度优先搜索 BFS</li><li>最短路径，Dijkstra 算法</li></ol></li><li>应用场景： <ol><li>社交网络（好友推荐、影响力分析）</li><li>路径规划（导航系统、物流优化）</li><li>网络拓扑（路由器布局、互联网结构）</li><li>推荐系统（用户-商品关系图）</li><li>知识图谱（实体关系建模）</li><li>编译器优化（控制流图）</li><li>社交网络、地图导航、推荐系统等</li></ol></li></ul><h2 id="时间复杂度-空间复杂度" tabindex="-1">时间复杂度&amp;空间复杂度 <a class="header-anchor" href="#时间复杂度-空间复杂度" aria-label="Permalink to &quot;时间复杂度&amp;空间复杂度&quot;">​</a></h2><p>时间复杂度和空间复杂度是<code>衡量算法效率的核心指标</code>，用于分析算法在不同输入规模下的资源消耗情况。</p><h3 id="什么是时间复杂度-⚡️" tabindex="-1">什么是时间复杂度？⚡️ <a class="header-anchor" href="#什么是时间复杂度-⚡️" aria-label="Permalink to &quot;什么是时间复杂度？⚡️&quot;">​</a></h3><p>衡量<code>算法运行时间</code>随输入规模增长的变化趋势，通常用大O符号（O）表示。<code>消耗CPU</code></p><ul><li>常见的时间复杂度</li></ul><table tabindex="0"><thead><tr><th>复杂度</th><th>名称</th><th>示例</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>常数时间</td><td>数组随机访问、哈希表查找</td></tr><tr><td><strong>O(log n)</strong></td><td>对数时间</td><td>二分查找、平衡二叉搜索树操作</td></tr><tr><td><strong>O(n)</strong></td><td>线性时间</td><td>遍历数组、链表查找</td></tr><tr><td><strong>O(n log n)</strong></td><td>线性对数时间</td><td>快速排序、归并排序</td></tr><tr><td><strong>O(n²)</strong></td><td>平方时间</td><td>冒泡排序、选择排序</td></tr><tr><td><strong>O(2ⁿ)</strong></td><td>指数时间</td><td>斐波那契递归解法</td></tr><tr><td><strong>O(n!)</strong></td><td>阶乘时间</td><td>旅行商问题暴力解法</td></tr></tbody></table><ul><li>计算规则 <ul><li>忽略常数项：O(2n) → O(n)</li><li>取最高阶项：O(n² + n) → O(n²)</li><li>循环嵌套相乘：两层循环 → O(n × m)</li></ul></li></ul><p><img src="'+d+'" alt="复杂度"></p><h3 id="什么是空间复杂度-⛰️" tabindex="-1">什么是空间复杂度？⛰️ <a class="header-anchor" href="#什么是空间复杂度-⛰️" aria-label="Permalink to &quot;什么是空间复杂度？⛰️&quot;">​</a></h3><p>衡量算法运行时<code>额外占用内存</code>随输入规模增长的变化趋势，同样用大O表示。<code>消耗内存</code></p><ul><li>常见空间复杂度</li></ul><table tabindex="0"><thead><tr><th>复杂度</th><th>名称</th><th>示例</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>常数空间</td><td>原地排序（如冒泡排序）</td></tr><tr><td><strong>O(n)</strong></td><td>线性空间</td><td>数组、哈希表存储</td></tr><tr><td><strong>O(n²)</strong></td><td>平方空间</td><td>邻接矩阵存储图</td></tr></tbody></table><ul><li>计算规则 <ul><li>只计算额外空间（不包括输入数据本身）</li><li>递归调用栈计入空间复杂度</li></ul></li></ul><h3 id="实际应用中的取舍" tabindex="-1">实际应用中的取舍 <a class="header-anchor" href="#实际应用中的取舍" aria-label="Permalink to &quot;实际应用中的取舍&quot;">​</a></h3><ul><li><p>时间优先：实时系统、高频交易（如用空间换时间的缓存策略）。</p></li><li><p>空间优先：嵌入式设备、内存受限场景（如用时间换空间的流式处理）。</p></li></ul>',39)]))}const g=t(o,[["render",r]]);export{b as __pageData,g as default};
