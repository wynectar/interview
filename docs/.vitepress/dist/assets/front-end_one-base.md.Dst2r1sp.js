import{_ as n,c as a,o as d,ag as l,j as t,a as i}from"./chunks/framework.Bw-5EFTY.js";const e="/assets/flow-c.DY0JJ9kh.jpg",o="/assets/flow-py.DqDzJSSv.jpg",r="/assets/flow-feng.BoTL-69P.jpg",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/one-base.md","filePath":"front-end/one-base.md","lastUpdated":null}'),p={name:"front-end/one-base.md"},h={class:"details custom-block"},g={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.53ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 3770.1 915.9","aria-hidden":"true"};function c(u,s,m,F,y,T){return d(),a("div",null,[s[11]||(s[11]=l(`<h2 id="进程和线程的区别" tabindex="-1">进程和线程的区别 <a class="header-anchor" href="#进程和线程的区别" aria-label="Permalink to &quot;进程和线程的区别&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ul><li><p>进程：是<code>操作系统资源分配的基本单位</code>，是程序的一次执行实例。每个进程拥有独立的地址空间、代码、数据和系统资源（如文件、内存等）。</p><p>🌰例如：运行中的浏览器、Word 程序等都是一个独立的进程。</p></li><li><p>线程：是<code>CPU调度的基本单位</code>，是进程内的一个执行单元（或称为“轻量级进程”）。一个进程可以包含多个线程，所有线程共享进程的资源（如内存、文件等）。</p><p>🌰例如：浏览器中的一个标签页可能由一个线程处理渲染，另一个线程处理网络请求。</p></li></ul><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>进程</strong></th><th><strong>线程</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>操作系统资源分配的基本单位，独立执行实例</td><td>CPU调度的基本单位，进程内的一个执行单元</td></tr><tr><td><strong>资源分配</strong></td><td>独立内存空间、文件描述符等系统资源</td><td>共享进程的资源（堆、全局变量、文件句柄等）</td></tr><tr><td><strong>切换开销</strong></td><td>高（需保存完整的地址空间、寄存器等上下文）</td><td>低（仅保存栈、寄存器等线程私有状态）</td></tr><tr><td><strong>通信方式</strong></td><td>IPC（管道、消息队列、共享内存等）</td><td>直接读写共享内存（需同步机制如锁、信号量）</td></tr><tr><td><strong>隔离性</strong></td><td>高（一个进程崩溃不影响其他进程）</td><td>低（线程崩溃可能导致整个进程崩溃）</td></tr><tr><td><strong>创建/销毁</strong></td><td>慢（需分配或释放独立资源）</td><td>快（仅需分配栈和少量寄存器状态）</td></tr><tr><td><strong>并发性</strong></td><td>多进程可并行运行在多核CPU上</td><td>多线程可并发（单核）或并行（多核）执行</td></tr><tr><td><strong>使用场景</strong></td><td>高隔离性需求（如浏览器多标签页、沙箱环境）</td><td>高并发、低延迟通信（如Web服务器、实时计算）</td></tr></tbody></table><p><strong>关键总结</strong></p><ol><li><strong>进程是资源容器，线程是执行单元</strong>。</li><li><strong>进程隔离性强，线程共享性强</strong>。</li><li><strong>线程切换更快，但需处理同步问题</strong>。</li><li>多进程适合<strong>安全性优先</strong>的场景，多线程适合<strong>性能优先</strong>的场景。</li></ol></details><h2 id="进程间的通信" tabindex="-1">进程间的通信 <a class="header-anchor" href="#进程间的通信" aria-label="Permalink to &quot;进程间的通信&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>进程间通信（IPC，Interprocess Communication）是指在不同进程之间传递数据或信号的机制。由于进程之间是相互隔离的（每个进程有独立的地址空间），操作系统提供了多种 IPC 方式来实现进程间通信。</p><ul><li>进程间通信（IPC）方式对比指南</li></ul><table tabindex="0"><thead><tr><th>IPC 方式</th><th>数据传输方向</th><th>适用场景</th><th>性能</th><th>复杂度</th><th>关键特点</th></tr></thead><tbody><tr><td><strong>匿名管道</strong></td><td>单向</td><td>Shell 命令、父子进程通信</td><td>低</td><td>低</td><td>基于文件描述符，仅限亲属进程</td></tr><tr><td><strong>命名管道(FIFO)</strong></td><td>单向/双向</td><td>无亲缘关系进程通信</td><td>低-中</td><td>中</td><td>文件系统可见，支持多读者/写者</td></tr><tr><td><strong>消息队列</strong></td><td>结构化消息</td><td>异步任务调度、日志系统</td><td>中</td><td>中</td><td>内核持久化，支持消息类型过滤</td></tr><tr><td><strong>共享内存</strong></td><td>直接访问</td><td>高性能计算、大数据交换</td><td>★★★★★</td><td>高</td><td>零拷贝，但需额外同步机制（如信号量）</td></tr><tr><td><strong>信号量</strong></td><td>无数据</td><td>进程同步、资源竞争控制</td><td>中</td><td>中</td><td>可解决生产者-消费者问题</td></tr><tr><td><strong>信号(Signal)</strong></td><td>无数据</td><td>进程控制、异常处理</td><td>低</td><td>低</td><td>异步通知，可靠性低（可能丢失信号）</td></tr><tr><td><strong>套接字(Socket)</strong></td><td>双向</td><td>跨机器通信、本地高性能IPC</td><td>中-高</td><td>高</td><td>支持TCP/UDP，Unix Domain Socket性能接近共享内存</td></tr><tr><td><strong>文件锁</strong></td><td>无数据</td><td>文件访问互斥</td><td>低</td><td>低</td><td><code>flock()</code>/<code>fcntl()</code>，适合简单同步场景</td></tr></tbody></table><hr><ul><li>快速选择建议</li></ul><ol><li><strong>需要最高性能</strong> → <strong>共享内存</strong>（配合信号量）</li><li><strong>简单通信</strong> → <strong>管道</strong>（亲属进程）/<strong>FIFO</strong>（非亲属进程）</li><li><strong>结构化消息</strong> → <strong>消息队列</strong></li><li><strong>跨机器通信</strong> → <strong>套接字</strong></li><li><strong>进程同步</strong> → <strong>信号量</strong>/<strong>文件锁</strong></li><li><strong>紧急控制</strong> → <strong>信号</strong>（但避免关键逻辑依赖信号）</li></ol><ul><li>注意事项</li><li><strong>共享内存</strong>最快但需要自行处理同步问题</li><li><strong>消息队列</strong>和<strong>管道</strong>有容量限制（检查<code>/proc/sys/fs/pipe-max-size</code>）</li><li><strong>Unix Domain Socket</strong>比网络套接字快30%以上（本地通信优选）</li><li>所有IPC方式在进程崩溃后需手动清理（除匿名管道）</li></ul></details><h2 id="单核-cpu-如何实现并发" tabindex="-1">单核 CPU 如何实现并发 <a class="header-anchor" href="#单核-cpu-如何实现并发" aria-label="Permalink to &quot;单核 CPU 如何实现并发&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>在单核 CPU 上，虽然同一时刻<code>只能执行一个线程或进程</code>，但通过操作系统的<code>任务调度</code>和<code>时间片轮转</code>机制，可以实现并发（Concurrency）。</p><ol><li>时间片轮转（Time-Sharing）</li></ol><ul><li>操作系统为每个任务（进程/线程）分配一个极短的时间片（如 10-100ms）。</li><li>CPU 在每个时间片结束时强制切换任务（通过时钟中断触发）。</li><li>快速切换任务，让用户感觉多个任务在“同时运行”。</li></ul><ol start="2"><li>上下文切换</li></ol><ul><li>保存当前任务状态（寄存器、栈等），加载下一个任务状态</li></ul><ol start="3"><li>注意事项</li></ol><ul><li>并行是<code>同一时刻</code>有多个任务在<code>同时进行</code>，并发是<code>同一时间段</code>内有多个任务在<code>交替进行</code>。</li><li><code>并发 ≠ 并行</code>: 单核是并发（逻辑并行），多核是并行（物理并行）。</li><li>单核 CPU 的并发本质是<code>任务快速切换+资源</code>高效复用，而多核 CPU 才能实现真正的并行。</li></ul></details><h2 id="cpu-调度算法有哪些" tabindex="-1">CPU 调度算法有哪些？ <a class="header-anchor" href="#cpu-调度算法有哪些" aria-label="Permalink to &quot;CPU 调度算法有哪些？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>CPU 调度算法对比总结</p><table tabindex="0"><thead><tr><th><strong>调度算法</strong></th><th><strong>中文名</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>FCFS</strong></td><td>先来先服务</td><td>非抢占，按任务到达顺序执行</td><td>实现简单</td><td>长任务阻塞短任务</td><td>批处理系统</td></tr><tr><td><strong>SJF/SRTN</strong></td><td>短作业优先/最短剩余时间优先</td><td>优先执行耗时最短的任务</td><td>平均等待时间最短</td><td>需预知任务耗时</td><td>理论优化场景</td></tr><tr><td><strong>RR</strong></td><td>时间片轮转</td><td>固定时间片轮流执行任务</td><td>公平，响应快</td><td>上下文切换开销大</td><td>分时系统（如桌面OS）</td></tr><tr><td><strong>Priority Scheduling</strong></td><td>优先级调度</td><td>按优先级分配CPU</td><td>灵活性高</td><td>低优先级任务可能饥饿</td><td>实时系统/游戏引擎</td></tr><tr><td><strong>Multilevel Queue</strong></td><td>多级队列调度</td><td>不同优先级队列使用不同策略</td><td>分类管理任务</td><td>配置复杂</td><td>混合负载环境</td></tr><tr><td><strong>MLFQ</strong></td><td>多级反馈队列</td><td>动态调整任务优先级（根据行为）</td><td>平衡响应和吞吐量</td><td>实现复杂度高</td><td>通用操作系统（如Linux）</td></tr><tr><td><strong>CFS</strong></td><td>完全公平调度</td><td>按<code>vruntime</code>公平分配CPU时间</td><td>极致公平性</td><td>计算开销稍大</td><td>Linux默认调度器</td></tr><tr><td><strong>EDF</strong></td><td>最早截止时间优先</td><td>优先执行截止时间最近的任务</td><td>实时性最优</td><td>需严格时间约束</td><td>硬实时系统（如航天控制）</td></tr><tr><td><strong>RMS</strong></td><td>速率单调调度</td><td>周期越短的任务优先级越高</td><td>适合周期性任务</td><td>CPU利用率≤69%的理论限制</td><td>嵌入式实时系统</td></tr></tbody></table><hr><p><strong>关键说明</strong></p><ol><li><p><strong>抢占式 vs 非抢占式</strong></p><ul><li>抢占式（如RR、SRTN）：允许中断当前任务。</li><li>非抢占式（如FCFS）：任务必须主动释放CPU。</li></ul></li><li><p><strong>适用场景选择</strong></p><ul><li><strong>交互式系统</strong> → RR 或 MLFQ（响应速度快）</li><li><strong>批处理系统</strong> → SJF 或 FCFS（高吞吐量）</li><li><strong>实时系统</strong> → EDF 或 RMS（严格截止时间）</li></ul></li><li><p><strong>现代操作系统实践</strong></p><ul><li>Linux：默认采用 <strong>CFS</strong>（完全公平调度） + <strong>实时补丁</strong>（支持EDF）。</li><li>Windows：基于 <strong>多级反馈队列（MLFQ）</strong> 的变种。</li></ul></li></ol><p>扩展阅读</p><ul><li>Linux调度参数调整：<code>/proc/sys/kernel/sched_*</code></li><li>实时任务优先级设置：<code>chrt -f 99 &lt;command&gt;</code></li></ul></details><h2 id="linux-如何查找你的进程占用的那个端口" tabindex="-1">linux 如何查找你的进程占用的那个端口 <a class="header-anchor" href="#linux-如何查找你的进程占用的那个端口" aria-label="Permalink to &quot;linux 如何查找你的进程占用的那个端口&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ol><li>使用 netstat 命令（经典方法）</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查询所有端口占用情况</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tulnp</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查询特定端口占用情况</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tulnp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">进程名或端口</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">号</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>选项说明：</p><ul><li>-t：显示 TCP 端口</li><li>-u：显示 UDP 端口</li><li>-l：仅显示监听（LISTEN）状态的端口</li><li>-n：以数字形式显示端口（不解析服务名）</li><li>-p：显示进程 PID 和名称（需要 sudo）</li></ul><p>示例</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查找 nginx 进程占用的端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tulnp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查找 80 端口被哪个进程占用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tulnp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;:80&quot;</span></span></code></pre></div><ol start="2"><li>使用 ss 命令（netstat 的现代替代）</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ss 比 netstat 更快，语法类似</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ss</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tulnp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">进程名或端口</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">号</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><ol start="3"><li>使用 lsof 命令（查看进程打开的文件和端口）</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lsof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">端口</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">号</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 查看指定端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lsof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -P</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">进程</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">名</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 查看指定进程</span></span></code></pre></div><p>选项说明：</p><ul><li>-i：显示网络连接</li><li>-P：以数字形式显示端口（不解析服务名）</li><li>-n：以数字形式显示 IP（不解析主机名）</li></ul><p>示例</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查找 22 端口（SSH）的占用进程</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lsof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :22</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查找 nginx 进程的所有网络连接</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lsof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -P</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span></span></code></pre></div></details><h2 id="单核服务器连接数超载了怎么办" tabindex="-1">单核服务器连接数超载了怎么办 <a class="header-anchor" href="#单核服务器连接数超载了怎么办" aria-label="Permalink to &quot;单核服务器连接数超载了怎么办&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ul><li><p>优化代码和查询</p><p>确保应用程序代码和数据库查询是高效的，以减少每个连接的资源消耗</p></li><li><p>使用负载均衡</p><p>将流量分配到多个服务器上，以分散负载</p></li><li><p>增加连接池</p><p>使用连接池来管理数据库连接，减少连接的创建和销毁开销</p></li><li><p>限制连接数</p><p>配置服务器以限制每个客户端的最大连接数，以防止单个客户端占用过多资源</p></li><li><p>使用缓存</p><p>利用缓存机制（如 Redis，Memcached）来减少对数据库的访问次数</p></li></ul></details><h2 id="请简述一个编译器的执行过程。前端有哪些常见的编译工具" tabindex="-1">请简述一个编译器的执行过程。前端有哪些常见的编译工具？ <a class="header-anchor" href="#请简述一个编译器的执行过程。前端有哪些常见的编译工具" aria-label="Permalink to &quot;请简述一个编译器的执行过程。前端有哪些常见的编译工具？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>编译器的执行过程</p><ol><li><p>词法分析</p><p>将源代码转换为一系列的标记（tokens，如<code>if</code>, <code>(</code>, <code>x</code>），这些标记是编程语言的基本语法单位</p></li><li><p>语法分析</p><p>根据语言的语法规则，将标记序列转换为语法书（parse tree），也称为抽象语法树（AST），检查语法是否正确</p></li><li><p>语义分析</p><p>检查语法树是否符合语言的语义规则，例如类型检查，作用域检查等</p></li><li><p>中间代码生成</p><p>将语法树转换为中间代码，这种代码通常独立于机器</p></li><li><p>代码优化</p><p>对中间代码进行优化，以提高程序的执行效率，如删除冗余代码、循环优化等</p></li><li><p>目标代码生成</p></li></ol><p>将中间代码转换为目标机器代码</p><ol start="7"><li>代码生成后优化 - 对生成的目标代码进行进一步优化</li></ol><p>前端常见的编译工具</p><ul><li><p>Babel</p><p>用于将现代 JavaScript 代码转换为向后兼容的版本</p></li><li><p>TypeScript Compiler</p><p>将 TypeScript 代码转换为 JavaScript</p></li><li><p>Sass/SCSS</p><p>将 Sass/SCSS 代码转换为 CSS</p></li><li><p>Webpack</p><p>用于打包 JavaScript 模块，并支持多种编译和转换插件</p></li></ul></details><h2 id="什么是编译型语言和解释型语言-他们有什么区别" tabindex="-1">什么是编译型语言和解释型语言，他们有什么区别？ <a class="header-anchor" href="#什么是编译型语言和解释型语言-他们有什么区别" aria-label="Permalink to &quot;什么是编译型语言和解释型语言，他们有什么区别？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>编译型语言 vs 解释型语言</p><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th>编译型语言</th><th>解释型语言</th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>源代码编译为机器码后直接执行</td><td>源代码由解释器逐行翻译执行</td></tr><tr><td><strong>编译过程</strong></td><td>需要提前编译（生成二进制文件）</td><td>无需编译，直接运行</td></tr><tr><td><strong>运行依赖</strong></td><td>仅需可执行文件</td><td>需安装解释器（如Python需<code>python</code>环境）</td></tr><tr><td><strong>执行速度</strong></td><td>⚡️ 快（直接运行机器码）</td><td>🐢 慢（实时翻译额外开销）</td></tr><tr><td><strong>跨平台性</strong></td><td>❌ 需针对不同平台编译</td><td>✅ 一次编写，跨平台运行（解释器适配底层）</td></tr><tr><td><strong>调试便利性</strong></td><td>❌ 调试需符号表，修改后需重新编译</td><td>✅ 支持逐行调试，动态修改代码</td></tr><tr><td><strong>代码安全性</strong></td><td>✅ 二进制文件难以反编译</td><td>❌ 源代码通常直接分发（如<code>.py</code>文件）</td></tr><tr><td><strong>典型代表</strong></td><td>C、C++、Go、Rust</td><td>Python、JavaScript、Ruby、PHP</td></tr></tbody></table><p>工作流程示例</p><ul><li>编译型语言（以C为例）</li></ul><p><img src="`+e+'" alt=""></p><ul><li>解释型语言（以Python为例）</li></ul><p><img src="'+o+'" alt=""></p></details><h2 id="简述-js-垃圾回收的过程。用什么算法" tabindex="-1">简述 JS 垃圾回收的过程。用什么算法？ <a class="header-anchor" href="#简述-js-垃圾回收的过程。用什么算法" aria-label="Permalink to &quot;简述 JS 垃圾回收的过程。用什么算法？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ul><li><p>核心目标</p><p>自动释放程序中不再使用的内存，防止内存泄漏。</p></li><li><p>垃圾回收过程</p></li></ul><ol><li><p>标记阶段（Marking）</p><ul><li>从根对象（Roots）出发（如全局变量、当前调用栈中的变量），递归遍历所有可达对象。</li><li>被访问到的对象标记为“可达”（活动对象）。</li></ul></li><li><p>清除阶段（Sweeping）</p><ul><li>遍历堆内存，回收所有未被标记为“可达”的对象占用的内存。</li><li>未被标记的对象视为“不可达”（垃圾）。</li></ul></li><li><p>整理阶段（Compacting，可选）</p><ul><li>部分引擎（如V8）会整理内存碎片，提升后续内存分配效率。</li></ul></li></ol><ul><li>垃圾回收算法</li></ul><ol><li>标记-清除算法（Mark-and-Sweep） <ul><li>原理：先标记所有活动对象，再清除未标记的对象。</li><li>优点：解决循环引用问题（旧版IE的引用计数算法无法处理）。</li><li>缺点：内存碎片化，可能引发后续分配性能下降。</li></ul></li><li>引用计数算法（Reference Counting） <ul><li>原理：每个对象维护一个引用计数器，归零时立即回收。</li><li>缺点：无法处理循环引用（如两个对象相互引用但已无外部访问）。</li><li>现状：现代JS引擎已弃用，仅旧版IE使用。</li></ul></li><li>分代收集（Generational Collection），原理（V8引擎采用）： <ul><li>新生代（Young Generation）：使用 Scavenge算法（复制算法），将内存分为From和To空间，存活对象从From复制到To，清空From。</li><li>老生代（Old Generation）：存活较久的对象晋升至此，使用 标记-清除 + 标记-整理 组合算法。</li></ul></li><li>增量标记（Incremental Marking）与惰性清理（Lazy Sweeping），优化策略： <ul><li>将标记阶段分解为多个小任务，穿插在JS执行中，避免长时间停顿（Stop-The-World）。</li><li>惰性清理延迟内存释放，减少对主线程的阻塞。</li></ul></li></ol></details><h2 id="冯·诺依曼架构是什么" tabindex="-1">冯·诺依曼架构是什么？ <a class="header-anchor" href="#冯·诺依曼架构是什么" aria-label="Permalink to &quot;冯·诺依曼架构是什么？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><p>由数学家冯·诺依曼于1945年提出，核心思想是将<code>程序和数据</code>存储在同一个存储器中，通过<code>共享总线</code>进行交互。</p><ol><li>五大核心组件</li></ol><ul><li><code>运算器 (ALU)</code> 执行算术和逻辑运算（如加减乘除、与或非）。</li><li><code>控制器 (CU)</code> 从内存读取指令，解码并控制其他部件协同工作（如指挥ALU运算）。</li><li><code>存储器 (Memory)</code> 存储程序和数据（统一存储，区别于哈佛架构）。</li><li><code>输入设备</code> 接收外部数据（如键盘、鼠标）。</li><li><code>输出设备</code> 输出计算结果（如显示器、打印机）。</li></ul><ol start="2"><li>工作流程 <img src="'+r+'" alt=""></li></ol></details><h2 id="计算机内部为何使用二进制" tabindex="-1">计算机内部为何使用二进制？ <a class="header-anchor" href="#计算机内部为何使用二进制" aria-label="Permalink to &quot;计算机内部为何使用二进制？&quot;">​</a></h2><details class="details custom-block"><summary>参考答案</summary><ol><li>硬件层面：物理实现的天然适配</li></ol><ul><li><p><code>二态器件稳定性</code> 电子元件（如晶体管）只有两种明确状态：开（1）：高电压（如5V）； 关（0）：低电压（如0V）</p><p>模拟信号易受噪声干扰，而二进制抗干扰能力极强</p></li><li><p><code>制造工艺简单</code></p></li><li><p><code>错误率低</code> 二进制信号的容错范围大（如0-0.8V判为0，2.4-5V判为1），降低误判风险。</p></li></ul><ol start="2"><li>数学与逻辑层面：完美契合布尔代数</li></ol><ul><li><code>布尔代数的直接映射</code> 二进制与布尔逻辑（AND、OR、NOT）完全对应：1 = 真（True）; 0 = 假（False）</li><li><code>算术运算的统一性</code> 二进制简化了加减乘除的实现</li></ul><ol start="3"><li>工程与历史因素</li></ol><ul><li><code>早期计算机的继承</code></li><li><code>标准化与扩展性</code> 二进制可轻松扩展为更高层的数据表示（如ASCII字符、浮点数）和存储单位（字节、字长）。</li><li><code>与存储介质的兼容性</code> 存储设备（硬盘、内存）的磁极方向或电荷有无天然对应二进制的0/1。</li></ul></details><h2 id="二进制如何表示负数和小数" tabindex="-1">二进制如何表示负数和小数？ <a class="header-anchor" href="#二进制如何表示负数和小数" aria-label="Permalink to &quot;二进制如何表示负数和小数？&quot;">​</a></h2>',23)),t("details",h,[s[8]||(s[8]=t("summary",null,"参考答案",-1)),s[9]||(s[9]=t("p",null,[i("计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有"),t("code",null,"符号位"),i("和"),t("code",null,"数值位"),i("两部分，符号位都是"),t("code",null,"在最高位用0表示“正”，用1表示“负”")],-1)),t("ul",null,[t("li",null,[s[2]||(s[2]=i("8位二进制能表示 ")),t("mjx-container",g,[(d(),a("svg",k,s[0]||(s[0]=[l('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)" style="stroke-width:3;"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)" style="stroke-width:3;"></path></g></g></g>',1)]))),s[1]||(s[1]=t("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("msup",null,[t("mn",null,"2"),t("mn",null,"8")]),t("mo",null,"="),t("mn",null,"256")])],-1))]),s[3]||(s[3]=i(" 个数 ")),s[4]||(s[4]=t("ul",null,[t("li",null,[i("正数和0：0000 0000 (0) 到 0111 1111 ("),t("code",null,"127"),i(")")]),t("li",null,[i("负数：1000 0000 ("),t("code",null,"-128"),i(") 到 1111 1111 (-1)")])],-1))]),s[5]||(s[5]=t("li",null,[t("code",null,"数值一律用补码"),i("来表示和存储")],-1)),s[6]||(s[6]=t("li",null,"正数的反码、补码和原码相同",-1)),s[7]||(s[7]=t("li",null,[t("code",null,"1 0000 0000"),i(" (最高位的1溢出被丢弃，结果为0)")],-1))]),s[10]||(s[10]=l(`<ol><li>负数的表示：补码（Two&#39;s Complement） <ul><li>解决“0”的表示问题：原码和反码中，+0 (0000) 和 -0 (1000) 有两种表示，补码中“0”只有一种表示 (0000)。</li><li>最高位的1溢出被丢弃，结果为0</li><li>求一个负数的补码步骤:</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">第1步：写出该负数绝对值对应的二进制原码（正数形式）。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">第2步：按位取反（0变1，1变0），得到反码。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">第3步：将反码</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1，得到的就是补码。</span></span></code></pre></div></li></ol>`,1))])])}const Q=n(p,[["render",c]]);export{b as __pageData,Q as default};
