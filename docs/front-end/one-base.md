## 进程和线程的区别

::: details 参考答案
- 进程：是`操作系统资源分配的基本单位`，是程序的一次执行实例。每个进程拥有独立的地址空间、代码、数据和系统资源（如文件、内存等）。

    🌰例如：运行中的浏览器、Word 程序等都是一个独立的进程。

- 线程：是`CPU调度的基本单位`，是进程内的一个执行单元（或称为“轻量级进程”）。一个进程可以包含多个线程，所有线程共享进程的资源（如内存、文件等）。

    🌰例如：浏览器中的一个标签页可能由一个线程处理渲染，另一个线程处理网络请求。

| **特性**         | **进程**                                      | **线程**                                      |
|------------------|----------------------------------------------|----------------------------------------------|
| **定义**         | 操作系统资源分配的基本单位，独立执行实例       | CPU调度的基本单位，进程内的一个执行单元        |
| **资源分配**     | 独立内存空间、文件描述符等系统资源             | 共享进程的资源（堆、全局变量、文件句柄等）     |
| **切换开销**     | 高（需保存完整的地址空间、寄存器等上下文）     | 低（仅保存栈、寄存器等线程私有状态）           |
| **通信方式**     | IPC（管道、消息队列、共享内存等）              | 直接读写共享内存（需同步机制如锁、信号量）     |
| **隔离性**       | 高（一个进程崩溃不影响其他进程）               | 低（线程崩溃可能导致整个进程崩溃）             |
| **创建/销毁**    | 慢（需分配或释放独立资源）                     | 快（仅需分配栈和少量寄存器状态）               |
| **并发性**       | 多进程可并行运行在多核CPU上                    | 多线程可并发（单核）或并行（多核）执行         |
| **使用场景**     | 高隔离性需求（如浏览器多标签页、沙箱环境）     | 高并发、低延迟通信（如Web服务器、实时计算）    |

**关键总结**
1. **进程是资源容器，线程是执行单元**。  
2. **进程隔离性强，线程共享性强**。  
3. **线程切换更快，但需处理同步问题**。  
4. 多进程适合**安全性优先**的场景，多线程适合**性能优先**的场景。
:::

## 进程间的通信
::: details 参考答案
进程间通信（IPC，Interprocess Communication）是指在不同进程之间传递数据或信号的机制。由于进程之间是相互隔离的（每个进程有独立的地址空间），操作系统提供了多种 IPC 方式来实现进程间通信。

- 进程间通信（IPC）方式对比指南

| IPC 方式          | 数据传输方向 | 适用场景                          | 性能  | 复杂度 | 关键特点                                                                 |
|-------------------|--------------|-----------------------------------|-------|--------|--------------------------------------------------------------------------|
| **匿名管道**      | 单向         | Shell 命令、父子进程通信          | 低    | 低     | 基于文件描述符，仅限亲属进程                                              |
| **命名管道(FIFO)**| 单向/双向    | 无亲缘关系进程通信                | 低-中 | 中     | 文件系统可见，支持多读者/写者                                            |
| **消息队列**      | 结构化消息   | 异步任务调度、日志系统            | 中    | 中     | 内核持久化，支持消息类型过滤                                              |
| **共享内存**      | 直接访问     | 高性能计算、大数据交换            | ★★★★★ | 高     | 零拷贝，但需额外同步机制（如信号量）                                      |
| **信号量**        | 无数据       | 进程同步、资源竞争控制            | 中    | 中     | 可解决生产者-消费者问题                                                  |
| **信号(Signal)**  | 无数据       | 进程控制、异常处理                | 低    | 低     | 异步通知，可靠性低（可能丢失信号）                                        |
| **套接字(Socket)**| 双向         | 跨机器通信、本地高性能IPC         | 中-高 | 高     | 支持TCP/UDP，Unix Domain Socket性能接近共享内存                           |
| **文件锁**        | 无数据       | 文件访问互斥                      | 低    | 低     | `flock()`/`fcntl()`，适合简单同步场景                                    |

---

- 快速选择建议
1. **需要最高性能** → **共享内存**（配合信号量）
2. **简单通信** → **管道**（亲属进程）/**FIFO**（非亲属进程）
3. **结构化消息** → **消息队列**
4. **跨机器通信** → **套接字**
5. **进程同步** → **信号量**/**文件锁**
6. **紧急控制** → **信号**（但避免关键逻辑依赖信号）

- 注意事项
- **共享内存**最快但需要自行处理同步问题
- **消息队列**和**管道**有容量限制（检查`/proc/sys/fs/pipe-max-size`）
- **Unix Domain Socket**比网络套接字快30%以上（本地通信优选）
- 所有IPC方式在进程崩溃后需手动清理（除匿名管道）
:::

## 单核 CPU 如何实现并发

::: details 参考答案
在单核 CPU 上，虽然同一时刻`只能执行一个线程或进程`，但通过操作系统的`任务调度`和`时间片轮转`机制，可以实现并发（Concurrency）。

1. 时间片轮转（Time-Sharing）
- 操作系统为每个任务（进程/线程）分配一个极短的时间片（如 10-100ms）。
- CPU 在每个时间片结束时强制切换任务（通过时钟中断触发）。
- 快速切换任务，让用户感觉多个任务在“同时运行”。

2. 上下文切换

- 保存当前任务状态（寄存器、栈等），加载下一个任务状态

3. 注意事项
- 并行是`同一时刻`有多个任务在`同时进行`，并发是`同一时间段`内有多个任务在`交替进行`。
- `并发 ≠ 并行`: 单核是并发（逻辑并行），多核是并行（物理并行）。
- 单核 CPU 的并发本质是`任务快速切换+资源`高效复用，而多核 CPU 才能实现真正的并行。
:::

## CPU 调度算法有哪些？

::: details 参考答案
CPU 调度算法对比总结

| **调度算法**               | **中文名**                 | **特点**                                  | **优点**                | **缺点**                  | **适用场景**               |
|----------------------------|----------------------------|------------------------------------------|-------------------------|---------------------------|---------------------------|
| **FCFS**                   | 先来先服务                 | 非抢占，按任务到达顺序执行               | 实现简单                | 长任务阻塞短任务          | 批处理系统                |
| **SJF/SRTN**               | 短作业优先/最短剩余时间优先 | 优先执行耗时最短的任务                   | 平均等待时间最短        | 需预知任务耗时            | 理论优化场景              |
| **RR**                     | 时间片轮转                 | 固定时间片轮流执行任务                   | 公平，响应快            | 上下文切换开销大          | 分时系统（如桌面OS）      |
| **Priority Scheduling**     | 优先级调度                 | 按优先级分配CPU                          | 灵活性高                | 低优先级任务可能饥饿      | 实时系统/游戏引擎         |
| **Multilevel Queue**       | 多级队列调度               | 不同优先级队列使用不同策略               | 分类管理任务            | 配置复杂                  | 混合负载环境              |
| **MLFQ**                   | 多级反馈队列               | 动态调整任务优先级（根据行为）           | 平衡响应和吞吐量        | 实现复杂度高              | 通用操作系统（如Linux）   |
| **CFS**                    | 完全公平调度               | 按`vruntime`公平分配CPU时间              | 极致公平性              | 计算开销稍大              | Linux默认调度器           |
| **EDF**                    | 最早截止时间优先           | 优先执行截止时间最近的任务               | 实时性最优              | 需严格时间约束            | 硬实时系统（如航天控制）  |
| **RMS**                    | 速率单调调度               | 周期越短的任务优先级越高                 | 适合周期性任务          | CPU利用率≤69%的理论限制   | 嵌入式实时系统            |

---

**关键说明**
1. **抢占式 vs 非抢占式**  
   - 抢占式（如RR、SRTN）：允许中断当前任务。  
   - 非抢占式（如FCFS）：任务必须主动释放CPU。

2. **适用场景选择**  
   - **交互式系统** → RR 或 MLFQ（响应速度快）  
   - **批处理系统** → SJF 或 FCFS（高吞吐量）  
   - **实时系统** → EDF 或 RMS（严格截止时间）  

3. **现代操作系统实践**  
   - Linux：默认采用 **CFS**（完全公平调度） + **实时补丁**（支持EDF）。  
   - Windows：基于 **多级反馈队列（MLFQ）** 的变种。

扩展阅读
- Linux调度参数调整：`/proc/sys/kernel/sched_*`  
- 实时任务优先级设置：`chrt -f 99 <command>`
:::

## linux 如何查找你的进程占用的那个端口

::: details 参考答案
1. 使用 netstat 命令（经典方法）
```bash
# 查询所有端口占用情况
netstat -tulnp

# 查询特定端口占用情况
netstat -tulnp | grep <进程名或端口号>
```
选项说明：
- -t：显示 TCP 端口
- -u：显示 UDP 端口
- -l：仅显示监听（LISTEN）状态的端口
- -n：以数字形式显示端口（不解析服务名）
- -p：显示进程 PID 和名称（需要 sudo）

示例
```bash
# 查找 nginx 进程占用的端口
sudo netstat -tulnp | grep nginx

# 查找 80 端口被哪个进程占用
sudo netstat -tulnp | grep ":80"
```

2. 使用 ss 命令（netstat 的现代替代）
```bash
# ss 比 netstat 更快，语法类似
sudo ss -tulnp | grep <进程名或端口号>
```

3. 使用 lsof 命令（查看进程打开的文件和端口）
```bash
sudo lsof -i :<端口号>  # 查看指定端口
sudo lsof -i -P -n | grep <进程名>  # 查看指定进程
```
选项说明：
- -i：显示网络连接
- -P：以数字形式显示端口（不解析服务名）
- -n：以数字形式显示 IP（不解析主机名）

示例
```bash
# 查找 22 端口（SSH）的占用进程
sudo lsof -i :22

# 查找 nginx 进程的所有网络连接
sudo lsof -i -P -n | grep nginx
```
:::

## 单核服务器连接数超载了怎么办
::: details 参考答案
- 优化代码和查询

    确保应用程序代码和数据库查询是高效的，以减少每个连接的资源消耗

- 使用负载均衡

    将流量分配到多个服务器上，以分散负载

- 增加连接池

    使用连接池来管理数据库连接，减少连接的创建和销毁开销

- 限制连接数

    配置服务器以限制每个客户端的最大连接数，以防止单个客户端占用过多资源

- 使用缓存

    利用缓存机制（如 Redis，Memcached）来减少对数据库的访问次数
:::

## 请简述一个编译器的执行过程。前端有哪些常见的编译工具？
::: details 参考答案
编译器的执行过程

1. 词法分析

    将源代码转换为一系列的标记（tokens，如`if`, `(`, `x`），这些标记是编程语言的基本语法单位
2. 语法分析

    根据语言的语法规则，将标记序列转换为语法书（parse tree），也称为抽象语法树（AST），检查语法是否正确
3. 语义分析

    检查语法树是否符合语言的语义规则，例如类型检查，作用域检查等
4. 中间代码生成

    将语法树转换为中间代码，这种代码通常独立于机器
5. 代码优化

    对中间代码进行优化，以提高程序的执行效率，如删除冗余代码、循环优化等
6. 目标代码生成

将中间代码转换为目标机器代码

7. 代码生成后优化 - 对生成的目标代码进行进一步优化


前端常见的编译工具
- Babel

    用于将现代 JavaScript 代码转换为向后兼容的版本
- TypeScript Compiler

    将 TypeScript 代码转换为 JavaScript
- Sass/SCSS

    将 Sass/SCSS 代码转换为 CSS
- Webpack

    用于打包 JavaScript 模块，并支持多种编译和转换插件
:::

## 什么是编译型语言和解释型语言，他们有什么区别？
::: details 参考答案
编译型语言 vs 解释型语言

| **特性**         | 编译型语言                                     | 解释型语言                                     |
|------------------|-----------------------------------------------|-----------------------------------------------|
| **执行方式**     | 源代码编译为机器码后直接执行                   | 源代码由解释器逐行翻译执行                     |
| **编译过程**     | 需要提前编译（生成二进制文件）                 | 无需编译，直接运行                             |
| **运行依赖**     | 仅需可执行文件                                | 需安装解释器（如Python需`python`环境）         |
| **执行速度**     | ⚡️ 快（直接运行机器码）                        | 🐢 慢（实时翻译额外开销）                       |
| **跨平台性**     | ❌ 需针对不同平台编译                          | ✅ 一次编写，跨平台运行（解释器适配底层）        |
| **调试便利性**   | ❌ 调试需符号表，修改后需重新编译               | ✅ 支持逐行调试，动态修改代码                   |
| **代码安全性**   | ✅ 二进制文件难以反编译                        | ❌ 源代码通常直接分发（如`.py`文件）            |
| **典型代表**     | C、C++、Go、Rust                              | Python、JavaScript、Ruby、PHP                 |

工作流程示例
- 编译型语言（以C为例）

![](../imgs/flow-c.jpg)
- 解释型语言（以Python为例）

![](../imgs/flow-py.jpg)
:::

## 简述 JS 垃圾回收的过程。用什么算法？

::: details 参考答案
- 核心目标

    自动释放程序中不再使用的内存，防止内存泄漏。
- 垃圾回收过程

1. 标记阶段（Marking）
    - 从根对象（Roots）出发（如全局变量、当前调用栈中的变量），递归遍历所有可达对象。
    - 被访问到的对象标记为“可达”（活动对象）。

2. 清除阶段（Sweeping）
    - 遍历堆内存，回收所有未被标记为“可达”的对象占用的内存。
    - 未被标记的对象视为“不可达”（垃圾）。

3. 整理阶段（Compacting，可选）
    - 部分引擎（如V8）会整理内存碎片，提升后续内存分配效率。

- 垃圾回收算法

1. 标记-清除算法（Mark-and-Sweep）
    - 原理：先标记所有活动对象，再清除未标记的对象。
    - 优点：解决循环引用问题（旧版IE的引用计数算法无法处理）。
    - 缺点：内存碎片化，可能引发后续分配性能下降。
2. 引用计数算法（Reference Counting）
    - 原理：每个对象维护一个引用计数器，归零时立即回收。
    - 缺点：无法处理循环引用（如两个对象相互引用但已无外部访问）。
    - 现状：现代JS引擎已弃用，仅旧版IE使用。
3. 分代收集（Generational Collection），原理（V8引擎采用）：
    - 新生代（Young Generation）：使用 Scavenge算法（复制算法），将内存分为From和To空间，存活对象从From复制到To，清空From。
    - 老生代（Old Generation）：存活较久的对象晋升至此，使用 标记-清除 + 标记-整理 组合算法。
4. 增量标记（Incremental Marking）与惰性清理（Lazy Sweeping），优化策略：
    - 将标记阶段分解为多个小任务，穿插在JS执行中，避免长时间停顿（Stop-The-World）。
    - 惰性清理延迟内存释放，减少对主线程的阻塞。
:::

## 冯·诺依曼架构是什么？

::: details 参考答案
由数学家冯·诺依曼于1945年提出，核心思想是将`程序和数据`存储在同一个存储器中，通过`共享总线`进行交互。

1. 五大核心组件
- `运算器 (ALU)`	执行算术和逻辑运算（如加减乘除、与或非）。
- `控制器 (CU)`	从内存读取指令，解码并控制其他部件协同工作（如指挥ALU运算）。
- `存储器 (Memory)`	存储程序和数据（统一存储，区别于哈佛架构）。
- `输入设备`	接收外部数据（如键盘、鼠标）。
- `输出设备`	输出计算结果（如显示器、打印机）。

2. 工作流程
![](../imgs/flow-feng.jpg)

:::

## 计算机内部为何使用二进制？

::: details 参考答案
1. 硬件层面：物理实现的天然适配
- `二态器件稳定性` 
    电子元件（如晶体管）只有两种明确状态：开（1）：高电压（如5V）； 关（0）：低电压（如0V）

    模拟信号易受噪声干扰，而二进制抗干扰能力极强
- `制造工艺简单`
- `错误率低`  二进制信号的容错范围大（如0-0.8V判为0，2.4-5V判为1），降低误判风险。

2. 数学与逻辑层面：完美契合布尔代数
- `布尔代数的直接映射` 二进制与布尔逻辑（AND、OR、NOT）完全对应：1 = 真（True）; 0 = 假（False）
- `算术运算的统一性` 二进制简化了加减乘除的实现

3. 工程与历史因素
- `早期计算机的继承`
- `标准化与扩展性`	二进制可轻松扩展为更高层的数据表示（如ASCII字符、浮点数）和存储单位（字节、字长）。
- `与存储介质的兼容性`	存储设备（硬盘、内存）的磁极方向或电荷有无天然对应二进制的0/1。
:::

## 二进制如何表示负数和小数？

::: details 参考答案
计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有`符号位`和`数值位`两部分，符号位都是`在最高位用0表示“正”，用1表示“负”`

- 8位二进制能表示 $2^8 = 256$ 个数
    - 正数和0：0000 0000 (0) 到 0111 1111 (`127`)
    - 负数：1000 0000 (`-128`) 到 1111 1111 (-1)
- `数值一律用补码`来表示和存储
- 正数的反码、补码和原码相同
- `1 0000 0000` (最高位的1溢出被丢弃，结果为0)
- -128 的 8 位补码是一个由补码体系规则直接定义的边界值，其值为 `1000 0000`。
- 解决“0”的表示问题：原码和反码中，+0 (0000) 和 -0 (1000) 有两种表示，补码中“0”只有一种表示 (0000)


1. 负数的表示：补码（Two's Complement）
    - 取反加一得补码
    ```js
    |-5| 的原码：0000 0101 // 第1步：写出该负数绝对值对应的二进制原码（正数形式）。
    -5 的反码：1111 1010 // 第2步：按位取反（0变1，1变0），得到反码。
    -5 的补码：1111 1011 // 第3步：将反码 + 1，得到的就是补码。
    ```
    补码是否正确，可以用`绝对值的原码+补码`是否为0验证
    - 模减
    ```js
    // 模是数字总数（$2^n$），八进制中为（$2^8$）
    [-X]的补码 = [模 - X] 转化的二进制
    ```
2. 小数的表示：浮点数（Floating Point）
    - IEEE 754 单精度（32位）浮点数结构，有三个部分

    | **部分**       | **符号位 (S)**     | **指数位 (E)**        | **尾数位 (M)**              |
    |---------------|-------------------|----------------------|----------------------------|
    |位宽           |1 bit              |8 bits                 |23 bits                    |
    |作用           |决定正负            |决定范围                 |决定精度                   |
    |              |0正 1负             |(需用偏移码)             |表示小数点后的数字                    |

    计算公式：$Value = (-1)^S \times 1.M \times 2^{E-127}$

    以数字 `10.625` 为例转换为二进制小数
    - 整数部分（除以2直至商为0，余数逆序即为该整数的二进制） `10` -> `1010`
    - 小数部分（乘以2取整直至为0或到达精度，取整顺序即为该小数的二进制） `0.625` -> `0.625 × 2 = 1.25` -> 取整1 -> `0.25 × 2 = 0.5` -> 取整0 -> `0.5 × 2 = 1.0` -> 取整1 -> `.101`
    - 合并：`10.625` -> `1010.101`
:::

## 什么是虚拟内存，为何要使用虚拟内存？
::: details 参考答案
虚拟内存（Virtual Memory） 是操作系统提供的一种抽象机制。它为`每个进程`提供了一个`独立、连续且统一的私有地址空间`（称为虚拟地址空间），通过` CPU 中的内存管理单元`（MMU） 和操作系统内核协作，将进程使用的`虚拟地址 动态地映射`到物理内存的`物理地址` 上。

为何要使用虚拟内存？

核心目标是提供更`安全、稳定、高效`的内存管理方式
- `内存管理与保护（Memory Protection）`【最重要】: 虚拟内存为每个进程提供独立的地址空间。进程A无法“看到”或“访问”进程B的虚拟地址空间。防止系统崩溃。
- `简化内存分配与编程（Simplification）`: 程序在编译时`无需知道`它将来会被加载到物理内存的哪个地址，操作系统负责在运行时将虚拟地址映射到任意的物理地址。
- `实现内存交换（Swapping）`【常被误解的功能】: 操作系统可以将物理内存中`暂时不用的数据`“换出”到`硬盘上的交换空间`（Swap Space） 中，从而腾出空间给急需内存的程序。这才是“用磁盘扩展内存”的真正含义。
- `支持共享内存（Shared Memory）`: 通过虚拟内存，可以将`同一块`物理内存映射到`多个进程的不同虚拟地址`空间中。实现高效的进程间通信（IPC）和资源共享。
:::

## 什么是 Unicode 编码？它和常见的 UTF-8 有什么关系？

::: details 参考答案
- `Unicode 回答“是什么？”`：Unicode 的本质是一个字符集（Character Set）和一套码位标准，而不是具体的存储格式
- `UTF-8 回答“怎么存？”`：UTF-8 是 Unicode 的一种实现方式（或编码方案）。它解决了“如何将 Unicode 码点高效地`存储`到计算机内存和文件中”的问题。

    UTF-8（Unicode Transformation Format – 8-bit）是一种针对 Unicode 的可变长度字符编码方案。

    |字符类型|码位范围（近似）|占用字节数|优点|
    |---------------|-------------------|----------------------|----------------------------|
    |ASCII 字符	|U+0000 ~ U+007F	|1 字节	|完全兼容 ASCII，对英文文本极其高效|
    |大部分拉丁、阿拉伯文字等	|U+0080 ~ U+07FF	|2 字节	|   |
    |大部分中文、日文、韩文字符	|U+0800 ~ U+FFFF	|3 字节	|平衡了效率与通用性|
    |生僻字、表情符号(emoji)等	|U+10000 ~ ...	|4 字节	|可表示所有 Unicode 字符|

- UTF-8 并非唯一的编码方式，其他常见实现还包括：

|编码格式	|特点	|主要应用场景|
|---------------|-------------------|----------------------|
|UTF-8	|可变长度(1-4 字节)，兼容 ASCII，空间效率高	|Web（HTML, HTTP）、文件存储、Linux/Unix 系统，是事实上的国际标准。|
|UTF-16	|通常为2 或 4 个字节，长度固定或可变	|Java、JavaScript、C#、Windows API 内部常用。|
|UTF-32	|固定 4 个字节表示每个字符，简单但非常浪费空间	|主要用于程序内部处理，很少用于文件存储或传输。|
:::

## 简述计算机网络的 OSI 模型
::: details 参考答案
- 核心目的是使各种不同的计算机系统和网络设备能够以一种标准化的方式进行通信。

|层数	|名称	|功能简介	|关键协议/设备	|数据单位|
|---------------|-------------------|----------------------|----------------|----------------|
|7	|应用层	|为应用程序提供网络服务接口（用户直接接触）。	|HTTP, HTTPS, FTP, SMTP, DNS	|Data|
|6	|表示层	|负责数据翻译、加密解密、压缩解压缩（确保应用层能读懂数据）。	|SSL/TLS, JPEG, MPEG	|Data|
|5	|会话层	|负责建立、管理和终止两个通信主机之间的会话（对话）。	|RPC, PPTP	|Data|
|4	|传输层	|提供端到端的可靠或不可靠传输，负责流量控制和差错控制。	|TCP, UDP	|Segment (TCP) / Datagram (UDP)|
|3|	网络层	|负责逻辑寻址（IP地址）和路由选择（决定数据包如何穿越网络）。	|IP, ICMP, 路由器	|Packet|
|2	|数据链路层	|负责物理寻址（MAC地址），在直接相连的节点间可靠传输数据帧。	|Ethernet, PPP, 交换机, 网桥	|Frame|
|1	|物理层	|定义物理特性（电压、线缆、接口），在物理媒介上透明传输比特流。	|RJ45, 光纤, 同轴电缆, 集线器	|Bit|

- 传输层（TCP）的三次握手 和 应用层（TLS/SSL）的握手
    - TCP 三次握手: 客户端（Client）和服务器（Server）之间建立一个可靠的TCP连接。 `物理通话线路建立`
    - TLS/SSL 握手: 在已建立的TCP连接之上，建立一个安全的加密通道。用于交换密钥、验证身份（可选）、协商加密算法。`安全加密通道建立`
:::

## 一个域名对应一个 ip 吗
::: details 参考答案
1. 一个域名对应多个 IP 地址（一对多）
    - 主要用于负载均衡和故障转移，以提高网站的可用性、可靠性和性能。
    - `工作原理`：当你在 DNS 系统中查询一个大型网站（如 www.google.com 或 www.baidu.com) 时，DNS 服务器并不会返回一个 IP，而是返回一个IP 地址列表。你的计算机会随机或按顺序选择其中一个 IP 进行连接。
    - 使用 nslookup 或 dig 命令来查看一个域名对应了多少个 IP。
    ```bash
    nslookup www.google.com
    ```

2. 多个域名对应一个 IP 地址（多对一）
    - 在 Web 托管服务中非常普遍，特别是虚拟主机 (Virtual Hosting)。
    - `工作原理`：一台服务器（一个 IP 地址）上可以托管多个网站。当你的浏览器向这个 IP 地址发送请求时，它会同时在 HTTP 请求头中带上域名（Host: example.com）。服务器根据这个 Host 字段来判断用户想要访问的是哪个网站，然后返回相应的内容。

3. 一个域名也可以对应一个 IP 地址（一对一）
    - 需要直接、稳定连接的服务，通常会配置为独占一个 IP。

4. 一个域名也可以对应零个 IP 地址
    - 有些域名只用于特殊记录，并不直接提供 Web 访问。如`邮件交换记录 (MX Record)：mail.example.com`、`别名记录 (CNAME Record)：www.example.com`
:::


## UDP 和 TCP 协议的区别？有什么应用场景
::: details 参考答案
- 核心区别对比表

|特性	        |TCP (传输控制协议)	                |UDP (用户数据报协议)                               |
|---------------|---------------------------------|------------------------------------------------|
|连接方式	    |`面向连接 (Connection-oriented)`传输数据前必须先建立连接（三次握手）	|`无连接 (Connectionless)`无需建立连接，直接发送数据|
|可靠性	        |`可靠 (Reliable)`提供确认、重传、超时机制，保证数据不丢失、不重复、按序到达	|`不可靠 (Unreliable)`不保证送达，不保证顺序，可能丢包|
|数据顺序	    |`保证顺序 (Ordered)`对数据包进行排序，确保接收方按发送顺序读取|	`不保证顺序 (Unordered)`数据包可能乱序到达|
|流量控制	    |`有 (Flow Control)`通过滑动窗口机制，防止发送方发送过快导致接收方缓冲区溢出	|`无`|
|拥塞控制	    |`有 (Congestion Control)`通过慢启动、拥塞避免等算法降低网络拥堵|	`无`不管网络状态，始终以恒定速率发送|
|首部开销	    |`大` (20-60 字节)	|`小` (仅 8 字节)|
|传输速度	    |`相对慢`由于建立连接、确认、重传等机制，延迟较高|	`非常快`没有额外控制机制，延迟低|
|数据模式	    |`字节流 (Stream-oriented)`消息无边界，应用层需要自己处理|	`数据报 (Message-oriented)`保留消息边界，发送多少次，接收多少次|
|连接对象	    |`一对一`	|支持`一对一、一对多、多对多`|

- 应用场景
    - TCP 的应用场景 (需要可靠性的场景)：网页浏览 (HTTP/HTTPS)、电子邮件 (SMTP, POP3, IMAP)、文件传输 (FTP)、远程登录 (SSH, Telnet)、金融交易、数据库连接
    - UDP 的应用场景 (需要低延迟或高效率的场景)：视频流媒体、语音通话 (VoIP)、在线视频会议 (Zoom, Teams)、实时在线游戏、DNS 查询、广播/多播应用 (如 DHCP)
:::

## 数组和链表有什么区别？从内存结构上来说

::: details 参考答案
内存结构上的本质区别
-  数组 (Array)：连续的内存空间
-  链表 (Linked List)：分散的内存空间

由内存结构衍生的主要区别

|特性	        |数组 (Array)	                    |链表 (Linked List)                     |
|---------------|---------------------------------|----------------------------------------|
|内存分配方式   |静态内存分配 (通常)    |动态内存分配   |
|内存使用效率   |	可能存在浪费        |基本无浪费     |
|大小可变性     |固定大小 (静态数组)    |动态大小           |
|访问方式       |`随机访问 (Random Access)` 通过索引直接访问，时间复杂度 O(1)|`顺序访问 (Sequential Access)` 必须从头开始遍历，时间复杂度 O(n)|
|插入/删除效率  |低效                   |高效       |
|缓存局部性 (Cache Locality)|好         |差     |
:::
